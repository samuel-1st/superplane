package grafana

import (
	"crypto/subtle"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/google/uuid"
	"github.com/mitchellh/mapstructure"
	"github.com/superplanehq/superplane/pkg/configuration"
	"github.com/superplanehq/superplane/pkg/core"
)

type OnAlertFiring struct{}

type OnAlertFiringConfig struct {
	SharedSecret      string `json:"sharedSecret"`
	WebhookBindingKey string `json:"webhookBindingKey,omitempty" mapstructure:"webhookBindingKey"`
}

func (t *OnAlertFiring) Name() string {
	return "grafana.onAlertFiring"
}

func (t *OnAlertFiring) Label() string {
	return "On Alert Firing"
}

func (t *OnAlertFiring) Description() string {
	return "Trigger when a Grafana alert rule is firing"
}

func (t *OnAlertFiring) Documentation() string {
	return `The On Alert Firing trigger starts a workflow when Grafana Unified Alerting sends a firing alert webhook.

## Setup

1. SuperPlane attempts to automatically create/update a Grafana Webhook contact point for this trigger.
2. If you set a Shared Secret in this trigger, SuperPlane includes it as an Authorization bearer token in the provisioned contact point.
3. Route your alert rule to the contact point created by SuperPlane.
4. If auto-provisioning is unavailable (permissions/API limitations), create the contact point manually using the webhook URL generated by SuperPlane.
5. For manual setup with Shared Secret, add an HTTP header to the contact point:
   - Authorization: Bearer <shared-secret>

## Event Data

The trigger emits the full Grafana webhook payload, including:
- status (firing/resolved)
- alerts array with labels and annotations
- groupLabels, commonLabels, commonAnnotations
- externalURL and other alerting metadata
`
}

func (t *OnAlertFiring) Icon() string {
	return "alert-triangle"
}

func (t *OnAlertFiring) Color() string {
	return "gray"
}

func (t *OnAlertFiring) Configuration() []configuration.Field {
	return []configuration.Field{
		{
			Name:        "sharedSecret",
			Label:       "Shared Secret",
			Type:        configuration.FieldTypeString,
			Sensitive:   true,
			Required:    false,
			Description: "Optional shared secret that must be sent as Authorization: Bearer <secret> header",
			Placeholder: "your-secret",
		},
	}
}

func (t *OnAlertFiring) Setup(ctx core.TriggerContext) error {
	if ctx.Integration == nil {
		return fmt.Errorf("missing integration context")
	}

	config := OnAlertFiringConfig{}
	if err := mapstructure.Decode(ctx.Configuration, &config); err != nil {
		return fmt.Errorf("error decoding configuration: %v", err)
	}

	bindingKey := getWebhookBindingKey(ctx)
	if bindingKey == "" {
		bindingKey = uuid.NewString()
	}

	requestConfig := OnAlertFiringConfig{
		SharedSecret:      strings.TrimSpace(config.SharedSecret),
		WebhookBindingKey: bindingKey,
	}

	if ctx.Webhook == nil {
		return fmt.Errorf("missing webhook context")
	}

	if err := ctx.Integration.RequestWebhook(requestConfig); err != nil {
		return err
	}

	webhookURL, err := ctx.Webhook.Setup()
	if err != nil {
		return err
	}

	if ctx.Metadata != nil {
		if err := setWebhookMetadata(ctx, webhookURL, bindingKey); err != nil && ctx.Logger != nil {
			ctx.Logger.Warnf("grafana onAlertFiring: failed to store webhook url metadata: %v", err)
		}
	}

	return nil
}

func (t *OnAlertFiring) Actions() []core.Action {
	return []core.Action{}
}

func (t *OnAlertFiring) HandleAction(ctx core.TriggerActionContext) (map[string]any, error) {
	return nil, nil
}

func (t *OnAlertFiring) HandleWebhook(ctx core.WebhookRequestContext) (int, error) {
	sharedSecret, err := resolveWebhookSharedSecret(ctx)
	if err != nil {
		return http.StatusInternalServerError, err
	}

	if sharedSecret != "" {
		authHeader := strings.TrimSpace(ctx.Headers.Get("Authorization"))
		if authHeader == "" {
			return http.StatusUnauthorized, fmt.Errorf("missing Authorization header")
		}
		if !strings.HasPrefix(authHeader, "Bearer ") {
			return http.StatusUnauthorized, fmt.Errorf("invalid Authorization header")
		}

		token := strings.TrimSpace(strings.TrimPrefix(authHeader, "Bearer "))
		if subtle.ConstantTimeCompare([]byte(token), []byte(sharedSecret)) != 1 {
			return http.StatusUnauthorized, fmt.Errorf("invalid Authorization token")
		}
	}

	if len(ctx.Body) == 0 {
		return http.StatusBadRequest, fmt.Errorf("empty body")
	}

	var payload map[string]any
	if err := json.Unmarshal(ctx.Body, &payload); err != nil {
		return http.StatusBadRequest, fmt.Errorf("error parsing request body: %v", err)
	}

	if !isFiringAlert(payload) {
		return http.StatusOK, nil
	}

	if err := ctx.Events.Emit("grafana.alert.firing", payload); err != nil {
		return http.StatusInternalServerError, fmt.Errorf("error emitting event: %v", err)
	}

	return http.StatusOK, nil
}

func (t *OnAlertFiring) Cleanup(ctx core.TriggerContext) error {
	return nil
}

func isFiringAlert(payload map[string]any) bool {
	return strings.EqualFold(extractString(payload["status"]), "firing")
}

func extractString(value any) string {
	text, ok := value.(string)
	if !ok {
		return ""
	}
	return strings.TrimSpace(text)
}

func resolveWebhookSharedSecret(ctx core.WebhookRequestContext) (string, error) {
	if ctx.Webhook != nil {
		secret, err := ctx.Webhook.GetSecret()
		if err != nil {
			return "", fmt.Errorf("error getting webhook secret: %w", err)
		}

		normalizedSecret := strings.TrimSpace(string(secret))
		if normalizedSecret != "" {
			return normalizedSecret, nil
		}
	}

	// Backward compatibility for older records where sharedSecret lived in configuration.
	config := OnAlertFiringConfig{}
	if err := mapstructure.Decode(ctx.Configuration, &config); err != nil {
		return "", fmt.Errorf("error decoding configuration: %v", err)
	}

	return strings.TrimSpace(config.SharedSecret), nil
}

func getWebhookBindingKey(ctx core.TriggerContext) string {
	if ctx.Metadata == nil {
		return ""
	}

	existing := ctx.Metadata.Get()
	existingMap, ok := existing.(map[string]any)
	if !ok {
		return ""
	}

	return strings.TrimSpace(extractString(existingMap["webhookBindingKey"]))
}

func setWebhookMetadata(ctx core.TriggerContext, webhookURL, bindingKey string) error {
	metadata := map[string]any{}
	if existing := ctx.Metadata.Get(); existing != nil {
		if existingMap, ok := existing.(map[string]any); ok {
			for key, value := range existingMap {
				metadata[key] = value
			}
		}
	}

	metadata["webhookUrl"] = webhookURL
	metadata["webhookBindingKey"] = bindingKey
	return ctx.Metadata.Set(metadata)
}
